"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WacapWrapper = void 0;
const session_registry_1 = require("./session-registry");
const event_bus_1 = require("../events/event-bus");
const storage_1 = require("../storage");
const fs_1 = require("fs");
const wrapper_helpers_1 = require("../handlers/wrapper.helpers");
/**
 * Main wrapper class for managing multiple WhatsApp sessions
 */
class WacapWrapper {
    config;
    registry;
    storageAdapter;
    globalBus;
    send;
    groups;
    contacts;
    chat;
    profile;
    presence;
    sessions;
    constructor(config = {}) {
        this.config = {
            sessionsPath: config.sessionsPath || './sessions',
            storageAdapter: config.storageAdapter || 'sqlite',
            debug: config.debug || false,
            logger: config.logger || { level: 'warn' },
            prismaClient: config.prismaClient,
            autoDisplayQR: config.autoDisplayQR !== false,
            qrCode: config.qrCode || { format: 'terminal' },
            browser: config.browser || ['Wacap', 'Chrome', '1.0.0'],
            connectionTimeout: config.connectionTimeout || 60000,
            maxRetries: config.maxRetries || 5,
        };
        // Initialize storage adapter
        if (this.config.storageAdapter === 'prisma') {
            if (!this.config.prismaClient) {
                throw new Error('Prisma storage adapter requires prismaClient to be provided in config');
            }
            this.storageAdapter = new storage_1.PrismaStorageAdapter(this.config.prismaClient);
        }
        else {
            this.storageAdapter = new storage_1.SQLiteStorageAdapter(this.config.sessionsPath);
        }
        this.globalBus = new event_bus_1.EventBus();
        this.registry = new session_registry_1.SessionRegistry(this.config, this.storageAdapter, this.globalBus);
        // High-level helper APIs for ergonomics
        this.send = {
            text: this.sendMessage.bind(this),
            media: this.sendMedia.bind(this),
            location: (sessionId, jid, latitude, longitude, options) => (0, wrapper_helpers_1.sendLocation)(this.registry, sessionId, jid, latitude, longitude, options),
            contact: (sessionId, jid, contact) => (0, wrapper_helpers_1.sendContact)(this.registry, sessionId, jid, contact),
            contacts: (sessionId, jid, contacts) => (0, wrapper_helpers_1.sendContacts)(this.registry, sessionId, jid, contacts),
            reaction: (sessionId, jid, messageId, emoji) => (0, wrapper_helpers_1.sendReaction)(this.registry, sessionId, jid, messageId, emoji),
            poll: (sessionId, jid, name, options, selectableCount = 1) => (0, wrapper_helpers_1.sendPoll)(this.registry, sessionId, jid, name, options, selectableCount),
            buttons: (sessionId, jid, text, buttons, footer) => (0, wrapper_helpers_1.sendButtons)(this.registry, sessionId, jid, text, buttons, footer),
            list: (sessionId, jid, title, text, buttonText, sections, footer) => (0, wrapper_helpers_1.sendList)(this.registry, sessionId, jid, title, text, buttonText, sections, footer),
        };
        this.sessions = {
            start: this.sessionStart.bind(this),
            stop: this.sessionStop.bind(this),
            stopAll: this.stopAllSessions.bind(this),
            restartAll: this.restartAllSessions.bind(this),
            startAll: this.startAllSessions.bind(this),
            startByIds: this.startByIds.bind(this),
            list: this.getSessionIds.bind(this),
            info: this.getSessionInfo.bind(this),
            get: this.findSession.bind(this),
        };
        this.groups = {
            create: (sessionId, subject, participants) => (0, wrapper_helpers_1.createGroup)(this.registry, sessionId, subject, participants),
            addParticipants: (sessionId, groupId, participants) => (0, wrapper_helpers_1.updateGroupParticipants)(this.registry, sessionId, groupId, participants, 'add'),
            removeParticipants: (sessionId, groupId, participants) => (0, wrapper_helpers_1.updateGroupParticipants)(this.registry, sessionId, groupId, participants, 'remove'),
            promoteParticipants: (sessionId, groupId, participants) => (0, wrapper_helpers_1.updateGroupParticipants)(this.registry, sessionId, groupId, participants, 'promote'),
            demoteParticipants: (sessionId, groupId, participants) => (0, wrapper_helpers_1.updateGroupParticipants)(this.registry, sessionId, groupId, participants, 'demote'),
            getInfo: (sessionId, groupId) => (0, wrapper_helpers_1.getGroupInfo)(this.registry, sessionId, groupId),
            updateSubject: (sessionId, groupId, subject) => (0, wrapper_helpers_1.updateGroupSubject)(this.registry, sessionId, groupId, subject),
            updateDescription: (sessionId, groupId, description) => (0, wrapper_helpers_1.updateGroupDescription)(this.registry, sessionId, groupId, description),
            updateSettings: (sessionId, groupId, setting) => (0, wrapper_helpers_1.updateGroupSettings)(this.registry, sessionId, groupId, setting),
            leave: (sessionId, groupId) => (0, wrapper_helpers_1.leaveGroup)(this.registry, sessionId, groupId),
            getInviteCode: (sessionId, groupId) => (0, wrapper_helpers_1.getGroupInviteCode)(this.registry, sessionId, groupId),
            revokeInviteCode: (sessionId, groupId) => (0, wrapper_helpers_1.revokeGroupInviteCode)(this.registry, sessionId, groupId),
            joinViaCode: (sessionId, inviteCode) => (0, wrapper_helpers_1.joinGroupViaCode)(this.registry, sessionId, inviteCode),
        };
        this.contacts = {
            check: (sessionId, phoneNumber) => (0, wrapper_helpers_1.checkNumberStatus)(this.registry, sessionId, phoneNumber),
            checkMultiple: (sessionId, phoneNumbers) => (0, wrapper_helpers_1.checkNumbersStatus)(this.registry, sessionId, phoneNumbers),
            getProfilePicture: (sessionId, jid, highRes = true) => (0, wrapper_helpers_1.getProfilePicture)(this.registry, sessionId, jid, highRes),
            getInfo: (sessionId, jid) => (0, wrapper_helpers_1.getContactInfo)(this.registry, sessionId, jid),
            block: (sessionId, jid) => (0, wrapper_helpers_1.blockContact)(this.registry, sessionId, jid),
            unblock: (sessionId, jid) => (0, wrapper_helpers_1.unblockContact)(this.registry, sessionId, jid),
            getBusinessProfile: (sessionId, jid) => (0, wrapper_helpers_1.getBusinessProfile)(this.registry, sessionId, jid),
        };
        this.chat = {
            markAsRead: (sessionId, jid, messageIds) => (0, wrapper_helpers_1.markAsRead)(this.registry, sessionId, jid, messageIds),
            archive: (sessionId, jid, archive = true) => (0, wrapper_helpers_1.archiveChat)(this.registry, sessionId, jid, archive),
            mute: (sessionId, jid, muteEndTime) => (0, wrapper_helpers_1.muteChat)(this.registry, sessionId, jid, muteEndTime),
            pin: (sessionId, jid, pin = true) => (0, wrapper_helpers_1.pinChat)(this.registry, sessionId, jid, pin),
            deleteMessage: (sessionId, jid, messageId, forEveryone = false) => (0, wrapper_helpers_1.deleteMessage)(this.registry, sessionId, jid, messageId, forEveryone),
            starMessage: (sessionId, jid, messageId, star = true) => (0, wrapper_helpers_1.starMessage)(this.registry, sessionId, jid, messageId, star),
            forwardMessage: (sessionId, jid, message, forceForward = false) => (0, wrapper_helpers_1.forwardMessage)(this.registry, sessionId, jid, message, forceForward),
        };
        this.profile = {
            updateStatus: (sessionId, status) => (0, wrapper_helpers_1.updateProfileStatus)(this.registry, sessionId, status),
            updateName: (sessionId, name) => (0, wrapper_helpers_1.updateProfileName)(this.registry, sessionId, name),
        };
        this.presence = {
            update: (sessionId, jid, presence) => (0, wrapper_helpers_1.sendPresence)(this.registry, sessionId, jid, presence),
        };
    }
    /**
     * Initialize the wrapper
     */
    async init() {
        await this.storageAdapter.init();
    }
    /**
     * Load and start all sessions stored in persistent storage.
     * Useful for SaaS / warm-boot scenarios.
     */
    async loadAllStoredSessions() {
        const sessionIds = await this.discoverStoredSessionIds();
        const started = [];
        for (const id of sessionIds) {
            if (this.registry.has(id))
                continue;
            try {
                await this.sessionStart(id);
                started.push(id);
            }
            catch (error) {
                if (this.config.debug) {
                    console.error(`[wacap] Failed to start stored session ${id}`, error);
                }
            }
        }
        return started;
    }
    /**
     * Start all sessions discovered in storage (alias for loadAllStoredSessions)
     */
    async startAllSessions() {
        return this.loadAllStoredSessions();
    }
    /**
     * Start several sessions by id list
     */
    async startByIds(ids, customConfig) {
        return this.registry.startByIds(ids, customConfig);
    }
    /**
     * Stop all active sessions
     */
    async stopAllSessions() {
        await this.registry.shutdownAll();
    }
    /**
     * Restart all currently known sessions
     */
    async restartAllSessions() {
        return this.registry.restartAll();
    }
    async discoverStoredSessionIds() {
        if (typeof this.storageAdapter.listSessions === 'function') {
            try {
                const ids = await this.storageAdapter.listSessions();
                if (ids.length > 0) {
                    return ids;
                }
            }
            catch (error) {
                if (this.config.debug) {
                    console.warn('[wacap] listSessions failed, falling back to filesystem scan', error);
                }
            }
        }
        try {
            const entries = await fs_1.promises.readdir(this.config.sessionsPath || './sessions', {
                withFileTypes: true,
            });
            return entries.filter((e) => e.isDirectory()).map((e) => e.name);
        }
        catch (error) {
            if (this.config.debug) {
                console.warn('[wacap] Unable to read sessions directory', error);
            }
            return [];
        }
    }
    /**
     * Start a new session or resume existing one
     */
    async sessionStart(sessionId, customConfig) {
        const session = await this.registry.create(sessionId, customConfig);
        return session;
    }
    /**
     * Stop a session
     */
    async sessionStop(sessionId) {
        await this.registry.destroy(sessionId);
    }
    /**
     * Find and return a session
     */
    findSession(sessionId) {
        return this.registry.get(sessionId);
    }
    /**
     * Get all active sessions
     */
    getAllSessions() {
        return this.registry.all();
    }
    /**
     * Get all session IDs
     */
    getSessionIds() {
        return this.registry.listIds();
    }
    /**
     * Get session info
     */
    getSessionInfo(sessionId) {
        const session = this.registry.get(sessionId);
        return session ? session.getInfo() : null;
    }
    /**
     * Check if session exists
     */
    hasSession(sessionId) {
        return this.registry.has(sessionId);
    }
    /**
     * Delete session data from storage (logout from WhatsApp)
     */
    async deleteSession(sessionId) {
        // Logout session if active (this will logout from WhatsApp)
        if (this.registry.has(sessionId)) {
            await this.registry.logout(sessionId);
        }
        // Delete from storage
        await this.storageAdapter.deleteSession(sessionId);
    }
    /**
     * Logout a session from WhatsApp (removes credentials, requires new QR scan)
     */
    async logoutSession(sessionId) {
        if (this.registry.has(sessionId)) {
            await this.registry.logout(sessionId);
        }
    }
    /**
     * Send a text message
     */
    async sendMessage(sessionId, jid, text, options) {
        return (0, wrapper_helpers_1.sendText)(this.registry, sessionId, jid, text, options);
    }
    /**
     * Send media (image, video, audio, document)
     */
    async sendMedia(sessionId, jid, media) {
        return (0, wrapper_helpers_1.sendMedia)(this.registry, sessionId, jid, media);
    }
    /**
     * Register event handler for a session
     */
    on(sessionId, event, handler) {
        const session = this.registry.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        session.getEventManager().on(event, handler);
    }
    /**
     * Register one-time event handler for a session
     */
    once(sessionId, event, handler) {
        const session = this.registry.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        session.getEventManager().once(event, handler);
    }
    /**
     * Get raw socket for advanced usage
     */
    getSocket(sessionId) {
        const session = this.registry.get(sessionId);
        return session ? session.getSocket() : null;
    }
    /**
     * Listen to events from all sessions globally.
     */
    onGlobal(event, handler) {
        this.globalBus.on(event, handler);
    }
    onceGlobal(event, handler) {
        this.globalBus.once(event, handler);
    }
    /**
     * Cleanup all sessions and close storage
     */
    async destroy() {
        // Stop all sessions
        await this.registry.shutdownAll();
        // Close storage
        await this.storageAdapter.close();
    }
}
exports.WacapWrapper = WacapWrapper;
//# sourceMappingURL=wacap-wrapper.js.map