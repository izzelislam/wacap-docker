import { WacapConfig, SessionInfo, MessageOptions, WacapEventType, EventHandler } from '../types';
import { Session } from './session';
import type { WASocket } from '@whiskeysockets/baileys';
/**
 * Main wrapper class for managing multiple WhatsApp sessions
 */
export declare class WacapWrapper {
    private config;
    private registry;
    private storageAdapter;
    private globalBus;
    send: {
        text: (sessionId: string, jid: string, text: string, options?: Partial<MessageOptions>) => Promise<any>;
        media: (sessionId: string, jid: string, media: {
            url?: string;
            buffer?: Buffer;
            mimetype?: string;
            caption?: string;
            fileName?: string;
        }) => Promise<any>;
        location: (sessionId: string, jid: string, latitude: number, longitude: number, options?: {
            name?: string;
            address?: string;
        }) => Promise<any>;
        contact: (sessionId: string, jid: string, contact: {
            name: string;
            phone: string;
        }) => Promise<any>;
        contacts: (sessionId: string, jid: string, contacts: Array<{
            name: string;
            phone: string;
        }>) => Promise<any>;
        reaction: (sessionId: string, jid: string, messageId: string, emoji: string) => Promise<any>;
        poll: (sessionId: string, jid: string, name: string, options: string[], selectableCount?: number) => Promise<any>;
        buttons: (sessionId: string, jid: string, text: string, buttons: Array<{
            id: string;
            text: string;
        }>, footer?: string) => Promise<any>;
        list: (sessionId: string, jid: string, title: string, text: string, buttonText: string, sections: Array<{
            title: string;
            rows: Array<{
                id: string;
                title: string;
                description?: string;
            }>;
        }>, footer?: string) => Promise<any>;
    };
    groups: {
        create: (sessionId: string, subject: string, participants: string[]) => Promise<any>;
        addParticipants: (sessionId: string, groupId: string, participants: string[]) => Promise<any>;
        removeParticipants: (sessionId: string, groupId: string, participants: string[]) => Promise<any>;
        promoteParticipants: (sessionId: string, groupId: string, participants: string[]) => Promise<any>;
        demoteParticipants: (sessionId: string, groupId: string, participants: string[]) => Promise<any>;
        getInfo: (sessionId: string, groupId: string) => Promise<any>;
        updateSubject: (sessionId: string, groupId: string, subject: string) => Promise<void>;
        updateDescription: (sessionId: string, groupId: string, description: string) => Promise<void>;
        updateSettings: (sessionId: string, groupId: string, setting: 'announcement' | 'not_announcement' | 'locked' | 'unlocked') => Promise<void>;
        leave: (sessionId: string, groupId: string) => Promise<void>;
        getInviteCode: (sessionId: string, groupId: string) => Promise<string>;
        revokeInviteCode: (sessionId: string, groupId: string) => Promise<string>;
        joinViaCode: (sessionId: string, inviteCode: string) => Promise<string>;
    };
    contacts: {
        check: (sessionId: string, phoneNumber: string) => Promise<{
            exists: boolean;
            jid: string;
        }>;
        checkMultiple: (sessionId: string, phoneNumbers: string[]) => Promise<Array<{
            number: string;
            exists: boolean;
            jid: string;
        }>>;
        getProfilePicture: (sessionId: string, jid: string, highRes?: boolean) => Promise<string | null>;
        getInfo: (sessionId: string, jid: string) => Promise<any>;
        block: (sessionId: string, jid: string) => Promise<void>;
        unblock: (sessionId: string, jid: string) => Promise<void>;
        getBusinessProfile: (sessionId: string, jid: string) => Promise<any>;
    };
    chat: {
        markAsRead: (sessionId: string, jid: string, messageIds: string[]) => Promise<void>;
        archive: (sessionId: string, jid: string, archive?: boolean) => Promise<void>;
        mute: (sessionId: string, jid: string, muteEndTime: number | null) => Promise<void>;
        pin: (sessionId: string, jid: string, pin?: boolean) => Promise<void>;
        deleteMessage: (sessionId: string, jid: string, messageId: string, forEveryone?: boolean) => Promise<void>;
        starMessage: (sessionId: string, jid: string, messageId: string, star?: boolean) => Promise<void>;
        forwardMessage: (sessionId: string, jid: string, message: any, forceForward?: boolean) => Promise<any>;
    };
    profile: {
        updateStatus: (sessionId: string, status: string) => Promise<void>;
        updateName: (sessionId: string, name: string) => Promise<void>;
    };
    presence: {
        update: (sessionId: string, jid: string | null, presence: 'available' | 'unavailable' | 'composing' | 'recording' | 'paused') => Promise<void>;
    };
    sessions: {
        start: (sessionId: string, customConfig?: Partial<WacapConfig>) => Promise<Session>;
        stop: (sessionId: string) => Promise<void>;
        stopAll: () => Promise<void>;
        restartAll: () => Promise<Session[]>;
        startAll: () => Promise<string[]>;
        startByIds: (ids: string[], customConfig?: Partial<WacapConfig>) => Promise<Session[]>;
        list: () => string[];
        info: (sessionId: string) => SessionInfo | null;
        get: (sessionId: string) => Session | undefined;
    };
    constructor(config?: WacapConfig);
    /**
     * Initialize the wrapper
     */
    init(): Promise<void>;
    /**
     * Load and start all sessions stored in persistent storage.
     * Useful for SaaS / warm-boot scenarios.
     */
    loadAllStoredSessions(): Promise<string[]>;
    /**
     * Start all sessions discovered in storage (alias for loadAllStoredSessions)
     */
    startAllSessions(): Promise<string[]>;
    /**
     * Start several sessions by id list
     */
    startByIds(ids: string[], customConfig?: Partial<WacapConfig>): Promise<Session[]>;
    /**
     * Stop all active sessions
     */
    stopAllSessions(): Promise<void>;
    /**
     * Restart all currently known sessions
     */
    restartAllSessions(): Promise<Session[]>;
    private discoverStoredSessionIds;
    /**
     * Start a new session or resume existing one
     */
    sessionStart(sessionId: string, customConfig?: Partial<WacapConfig>): Promise<Session>;
    /**
     * Stop a session
     */
    sessionStop(sessionId: string): Promise<void>;
    /**
     * Find and return a session
     */
    findSession(sessionId: string): Session | undefined;
    /**
     * Get all active sessions
     */
    getAllSessions(): Map<string, Session>;
    /**
     * Get all session IDs
     */
    getSessionIds(): string[];
    /**
     * Get session info
     */
    getSessionInfo(sessionId: string): SessionInfo | null;
    /**
     * Check if session exists
     */
    hasSession(sessionId: string): boolean;
    /**
     * Delete session data from storage (logout from WhatsApp)
     */
    deleteSession(sessionId: string): Promise<void>;
    /**
     * Logout a session from WhatsApp (removes credentials, requires new QR scan)
     */
    logoutSession(sessionId: string): Promise<void>;
    /**
     * Send a text message
     */
    sendMessage(sessionId: string, jid: string, text: string, options?: Partial<MessageOptions>): Promise<any>;
    /**
     * Send media (image, video, audio, document)
     */
    sendMedia(sessionId: string, jid: string, media: {
        url?: string;
        buffer?: Buffer;
        mimetype?: string;
        caption?: string;
        fileName?: string;
    }): Promise<any>;
    /**
     * Register event handler for a session
     */
    on(sessionId: string, event: WacapEventType, handler: EventHandler): void;
    /**
     * Register one-time event handler for a session
     */
    once(sessionId: string, event: WacapEventType, handler: EventHandler): void;
    /**
     * Get raw socket for advanced usage
     */
    getSocket(sessionId: string): WASocket | null;
    /**
     * Listen to events from all sessions globally.
     */
    onGlobal(event: WacapEventType, handler: EventHandler): void;
    onceGlobal(event: WacapEventType, handler: EventHandler): void;
    /**
     * Cleanup all sessions and close storage
     */
    destroy(): Promise<void>;
}
//# sourceMappingURL=wacap-wrapper.d.ts.map