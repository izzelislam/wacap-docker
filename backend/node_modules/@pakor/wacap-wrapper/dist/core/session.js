"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const baileys_1 = __importStar(require("@whiskeysockets/baileys"));
const pino_1 = __importDefault(require("pino"));
const path_1 = require("path");
const fs_1 = require("fs");
const types_1 = require("../types");
const events_1 = require("../events");
const handlers_1 = require("../handlers");
/**
 * WhatsApp session manager
 * Handles individual WhatsApp connections
 */
class Session {
    sessionId;
    config;
    socket = null;
    eventManager;
    storageAdapter;
    sessionPath;
    isConnecting = false;
    shouldReconnect = true;
    reconnecting = false;
    retryCount = 0;
    createdAt = new Date();
    startedAt;
    updatedAt;
    lastSeenAt;
    status = 'disconnected';
    lastError;
    globalBus;
    persistCreds;
    constructor(sessionId, config, storageAdapter, globalBus) {
        this.sessionId = sessionId;
        this.storageAdapter = storageAdapter;
        this.eventManager = new events_1.EventManager(sessionId);
        this.globalBus = globalBus;
        this.updatedAt = this.createdAt;
        // Set default config values
        this.config = {
            sessionsPath: config.sessionsPath || './sessions',
            storageAdapter: config.storageAdapter || 'sqlite',
            debug: config.debug || false,
            logger: config.logger || { level: 'warn' },
            prismaClient: config.prismaClient,
            autoDisplayQR: config.autoDisplayQR !== false,
            qrCode: config.qrCode || { format: 'terminal' },
            browser: config.browser || ['Wacap', 'Chrome', '1.0.0'],
            connectionTimeout: config.connectionTimeout || 60000,
            maxRetries: config.maxRetries || 5,
        };
        this.sessionPath = (0, path_1.join)(this.config.sessionsPath, this.sessionId);
        // Ensure session directory exists
        if (!(0, fs_1.existsSync)(this.sessionPath)) {
            (0, fs_1.mkdirSync)(this.sessionPath, { recursive: true });
        }
    }
    /**
     * Start the WhatsApp session
     */
    async start() {
        if (this.isConnecting || this.socket) {
            throw new Error(`Session ${this.sessionId} is already active or connecting`);
        }
        this.shouldReconnect = true;
        this.retryCount = 0;
        this.updateStatus('connecting');
        try {
            await this.connect();
        }
        catch (error) {
            this.updateStatus('error', error);
            throw error;
        }
    }
    /**
     * Connect to WhatsApp
     */
    async connect() {
        if (this.isConnecting || this.reconnecting)
            return;
        this.isConnecting = true;
        this.updateStatus('connecting');
        const logger = (0, pino_1.default)({
            level: this.config.logger.level,
        });
        // Load auth state
        try {
            const { state, saveCreds } = await (0, baileys_1.useMultiFileAuthState)(this.sessionPath);
            // Persist lightweight metadata to storage without double-serializing creds
            await this.storageAdapter.saveSession(this.sessionId, {
                updatedAt: Date.now(),
            });
            const persistCreds = async () => {
                await saveCreds();
                await this.storageAdapter.saveSession(this.sessionId, {
                    updatedAt: Date.now(),
                });
            };
            this.persistCreds = persistCreds;
            // Get latest version
            const { version } = await (0, baileys_1.fetchLatestBaileysVersion)();
            // Create socket
            this.socket = (0, baileys_1.default)({
                version,
                logger,
                printQRInTerminal: false, // We handle QR display ourselves
                auth: {
                    creds: state.creds,
                    keys: (0, baileys_1.makeCacheableSignalKeyStore)(state.keys, logger),
                },
                browser: this.config.browser,
                generateHighQualityLinkPreview: true,
                syncFullHistory: false,
                shouldIgnoreJid: (jid) => jid === 'status@broadcast',
            });
            this.socket.sessionId = this.sessionId;
            // Setup event handlers
            this.setupEventHandlers();
            this.startedAt = this.startedAt || new Date();
            this.touchActivity();
            this.emitBoth(types_1.WacapEventType.SESSION_START, {
                sessionId: this.sessionId,
                timestamp: this.startedAt,
            });
        }
        catch (error) {
            this.updateStatus('error', error);
            throw error;
        }
        finally {
            this.isConnecting = false;
        }
    }
    /**
     * Setup event handlers for the socket
     */
    setupEventHandlers() {
        if (!this.socket)
            return;
        const ctx = {
            sessionId: this.sessionId,
            socket: this.socket,
            config: this.config,
            storageAdapter: this.storageAdapter,
            emit: (event, data) => this.emitBoth(event, data),
            touchActivity: () => this.touchActivity(),
            updateStatus: (status, error) => this.updateStatus(status, error),
            handleReconnect: (error) => this.handleReconnect(error),
            handleLoggedOut: (error) => this.handleLoggedOut(error),
            resetRetry: () => {
                this.retryCount = 0;
            },
            setSocket: (socket) => {
                this.socket = socket;
            },
        };
        (0, handlers_1.registerConnectionHandlers)(ctx, this.persistCreds || (async () => { }));
        (0, handlers_1.registerMessageHandlers)(ctx);
        (0, handlers_1.registerGroupHandlers)(ctx);
        (0, handlers_1.registerTypingHandlers)(ctx);
        (0, handlers_1.registerContactHandlers)(ctx);
        (0, handlers_1.registerProfileHandlers)();
        (0, handlers_1.registerCallHandlers)(ctx);
    }
    /**
     * Update session status & last error message
     */
    updateStatus(status, error) {
        this.status = status;
        this.updatedAt = new Date();
        this.lastError = error
            ? error instanceof Error
                ? error.message
                : String(error)
            : undefined;
    }
    /**
     * Track activity timestamps
     */
    touchActivity() {
        const now = new Date();
        this.lastSeenAt = now;
        this.updatedAt = now;
    }
    /**
     * Handle reconnect attempts with retry budget
     */
    async handleReconnect(error) {
        if (!this.shouldReconnect || this.reconnecting)
            return;
        this.reconnecting = true;
        if (this.retryCount < this.config.maxRetries) {
            this.retryCount++;
            const backoffMs = Math.min(30000, 2000 * Math.pow(2, this.retryCount - 1));
            console.log(`[${this.sessionId}] Reconnecting... (Attempt ${this.retryCount}/${this.config.maxRetries}) in ${backoffMs}ms`);
            await (0, baileys_1.delay)(backoffMs);
            this.cleanupSocketListeners();
            this.socket = null;
            this.reconnecting = false;
            await this.connect();
        }
        else {
            console.error(`[${this.sessionId}] Max retry attempts reached. Stopping session.`);
            this.reconnecting = false;
            this.updateStatus('error', error);
            this.emitBoth(types_1.WacapEventType.SESSION_ERROR, {
                error: new Error('Max retry attempts reached'),
            });
        }
    }
    /**
     * Handle logged out / corrupted creds by resetting auth state
     */
    async handleLoggedOut(error) {
        this.updateStatus('disconnected', error);
        this.retryCount = 0;
        this.cleanupSocketListeners();
        this.socket = null;
        this.resetAuthState();
        if (!this.shouldReconnect)
            return;
        console.log(`[${this.sessionId}] Session logged out. Resetting auth and waiting for new QR.`);
        this.emitBoth(types_1.WacapEventType.SESSION_ERROR, {
            error: error || new Error('Logged out'),
        });
        await (0, baileys_1.delay)(1000);
        await this.connect();
    }
    /**
     * Wipes existing auth files to force a fresh QR
     */
    resetAuthState() {
        try {
            (0, fs_1.rmSync)(this.sessionPath, { recursive: true, force: true });
            (0, fs_1.mkdirSync)(this.sessionPath, { recursive: true });
        }
        catch (err) {
            console.error(`[${this.sessionId}] Failed to reset auth state`, err);
        }
    }
    /**
     * Stop the session without logging out (preserves credentials)
     * Use this for server restart/shutdown
     */
    async stop() {
        this.shouldReconnect = false;
        this.retryCount = 0;
        if (this.socket) {
            this.cleanupSocketListeners();
            // Hanya disconnect, TIDAK logout - credentials tetap tersimpan
            this.socket.end(undefined);
            this.socket = null;
        }
        this.updateStatus('disconnected');
        this.emitBoth(types_1.WacapEventType.SESSION_STOP, {
            sessionId: this.sessionId,
            timestamp: new Date(),
        });
    }
    /**
     * Logout and stop the session (removes credentials)
     * Use this to completely remove a session
     */
    async logout() {
        this.shouldReconnect = false;
        this.retryCount = 0;
        if (this.socket) {
            this.cleanupSocketListeners();
            try {
                await this.socket.logout();
            }
            catch (err) {
                // Ignore logout errors
            }
            this.socket = null;
        }
        this.updateStatus('disconnected');
        this.emitBoth(types_1.WacapEventType.SESSION_STOP, {
            sessionId: this.sessionId,
            timestamp: new Date(),
        });
    }
    /**
     * Get session info
     */
    getInfo() {
        const connectionState = this.socket?.user
            ? { connection: 'open' }
            : { connection: 'close' };
        return {
            sessionId: this.sessionId,
            status: this.status,
            isActive: !!this.socket,
            connectionState: connectionState,
            phoneNumber: this.socket?.user?.id?.split(':')[0],
            userName: this.socket?.user?.name,
            createdAt: this.createdAt,
            lastSeenAt: this.lastSeenAt,
            updatedAt: this.updatedAt,
            error: this.lastError,
        };
    }
    /**
     * Get event manager for registering event handlers
     */
    getEventManager() {
        return this.eventManager;
    }
    /**
     * Get the socket instance
     */
    getSocket() {
        return this.socket;
    }
    /**
     * Check if session is active
     */
    isActive() {
        return !!this.socket;
    }
    /**
     * Emit to local event manager and global bus
     */
    emitBoth(event, data) {
        const base = {
            sessionId: this.sessionId,
            timestamp: data?.timestamp || new Date(),
        };
        const payload = { ...base, ...data };
        this.eventManager.emit(event, payload);
        this.globalBus.emit(event, payload);
    }
    /**
     * Clean up event listeners on the current socket to avoid leaks
     */
    cleanupSocketListeners() {
        if (this.socket) {
            try {
                // Baileys event emitter allows removing all listeners without args
                this.socket.ev.removeAllListeners();
            }
            catch (err) {
                if (this.config.debug) {
                    console.warn(`[${this.sessionId}] Failed cleanup listeners`, err);
                }
            }
        }
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map