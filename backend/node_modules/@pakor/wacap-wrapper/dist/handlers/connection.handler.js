"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerConnectionHandlers = registerConnectionHandlers;
const baileys_1 = require("@whiskeysockets/baileys");
const qrcode_terminal_1 = __importDefault(require("qrcode-terminal"));
const qrcode_1 = __importDefault(require("qrcode"));
const types_1 = require("../types");
/**
 * Generate QR code as base64 data URL
 */
async function generateQRBase64(qr, options) {
    try {
        return await qrcode_1.default.toDataURL(qr, {
            width: options.width || 300,
            margin: options.margin || 2,
            color: {
                dark: options.darkColor || '#000000',
                light: options.lightColor || '#ffffff',
            },
        });
    }
    catch (error) {
        console.error('Failed to generate QR base64:', error);
        return '';
    }
}
function registerConnectionHandlers(ctx, persistCreds) {
    const { socket, config, sessionId, emit, touchActivity, updateStatus, handleReconnect, handleLoggedOut, resetRetry, setSocket, } = ctx;
    socket.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect, qr } = update;
        emit(types_1.WacapEventType.CONNECTION_UPDATE, {
            state: update,
            qr,
        });
        if (qr) {
            updateStatus('qr');
            // Determine QR format from config
            const qrConfig = config.qrCode || {};
            const format = qrConfig.format || (config.autoDisplayQR !== false ? 'terminal' : 'raw');
            // Print to terminal if format includes terminal
            if (format === 'terminal' || format === 'all') {
                console.log(`\n[${sessionId}] Scan this QR code to login:\n`);
                qrcode_terminal_1.default.generate(qr, { small: true });
            }
            // Generate base64 if format includes base64
            let qrBase64;
            if (format === 'base64' || format === 'all') {
                qrBase64 = await generateQRBase64(qr, {
                    width: qrConfig.width,
                    margin: qrConfig.margin,
                    darkColor: qrConfig.darkColor,
                    lightColor: qrConfig.lightColor,
                });
            }
            emit(types_1.WacapEventType.QR_CODE, {
                state: update,
                qr,
                qrBase64,
            });
        }
        if (connection === 'open') {
            console.log(`[${sessionId}] Connection opened successfully`);
            resetRetry();
            updateStatus('connected');
            touchActivity();
            emit(types_1.WacapEventType.CONNECTION_OPEN, {
                state: update,
            });
        }
        if (connection === 'close') {
            const statusCode = lastDisconnect?.error?.output?.statusCode;
            const isLoggedOut = statusCode === baileys_1.DisconnectReason.loggedOut;
            const shouldReconnect = statusCode !== baileys_1.DisconnectReason.loggedOut;
            setSocket(null);
            updateStatus(isLoggedOut ? 'disconnected' : 'connecting', lastDisconnect?.error);
            console.log(`[${sessionId}] Connection closed. Reconnecting: ${shouldReconnect}`);
            emit(types_1.WacapEventType.CONNECTION_CLOSE, {
                state: update,
                error: lastDisconnect?.error,
            });
            if (isLoggedOut) {
                await handleLoggedOut(lastDisconnect?.error);
                return;
            }
            if (shouldReconnect) {
                await handleReconnect(lastDisconnect?.error);
            }
        }
    });
    socket.ev.on('creds.update', persistCreds);
}
//# sourceMappingURL=connection.handler.js.map